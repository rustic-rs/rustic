use chrono::{DateTime, Local};
use rand::{thread_rng, RngCore};
use scrypt::Params;
use secrecy::ExposeSecret;
use serde::{Deserialize, Serialize};
use serde_with::{base64::Base64, serde_as};

use crate::{
    backend::{FileType, ReadBackend},
    crypto::{aespoly1305::Key, CryptoKey, SecretPassword},
    error::KeyFileErrorKind,
    id::Id,
    RusticResult,
};

pub(super) mod constants {
    pub(super) const fn num_bits<T>() -> usize {
        std::mem::size_of::<T>() * 8
    }
}

#[serde_as]
#[serde_with::apply(Option => #[serde(default, skip_serializing_if = "Option::is_none")])]
#[derive(Serialize, Deserialize, Debug)]
pub struct KeyFile {
    hostname: Option<String>,
    username: Option<String>,
    created: Option<DateTime<Local>>,
    kdf: String,
    #[serde(rename = "N")]
    n: u32,
    r: u32,
    p: u32,
    #[serde_as(as = "Base64")]
    data: Vec<u8>,
    #[serde_as(as = "Base64")]
    salt: Vec<u8>,
}

impl KeyFile {
    /// Generate a Key using the key derivation function from [`KeyFile`] and a given password
    pub fn kdf_key(&self, passwd: &SecretPassword) -> RusticResult<Key> {
        let params = Params::new(log_2(self.n)?, self.r, self.p, Params::RECOMMENDED_LEN)
            .map_err(KeyFileErrorKind::InvalidSCryptParameters)?;

        let mut key = [0; 64];
        scrypt::scrypt(
            passwd.expose_secret().as_bytes(),
            &self.salt,
            &params,
            &mut key,
        )
        .map_err(KeyFileErrorKind::OutputLengthInvalid)?;

        Ok(Key::from_slice(&key))
    }

    /// Extract a key from the data of the [`KeyFile`] using the given key.
    /// The key usually should be the key generated by [`kdf_key()`](Self::kdf_key)
    pub fn key_from_data(&self, key: &Key) -> RusticResult<Key> {
        let dec_data = key.decrypt_data(&self.data)?;
        Ok(serde_json::from_slice::<MasterKey>(&dec_data)
            .map_err(KeyFileErrorKind::DeserializingFromSliceFailed)?
            .key())
    }

    /// Extract a key from the data of the [`KeyFile`] using the key
    /// from the derivation function in combination with the given password.
    pub fn key_from_password(&self, passwd: &SecretPassword) -> RusticResult<Key> {
        self.key_from_data(&self.kdf_key(passwd)?)
    }

    /// Generate a new [`KeyFile`] from a given key and password.
    pub fn generate(
        key: Key,
        passwd: SecretPassword,
        hostname: Option<String>,
        username: Option<String>,
        with_created: bool,
    ) -> RusticResult<Self> {
        let masterkey = MasterKey::from_key(key);
        let params = Params::recommended();
        let mut salt = vec![0; 64];
        thread_rng().fill_bytes(&mut salt);

        let mut key = [0; 64];
        scrypt::scrypt(passwd.expose_secret().as_bytes(), &salt, &params, &mut key)
            .map_err(KeyFileErrorKind::OutputLengthInvalid)?;

        let key = Key::from_slice(&key);
        let data = key.encrypt_data(
            &serde_json::to_vec(&masterkey)
                .map_err(KeyFileErrorKind::CouldNotSerializeAsJsonByteVector)?,
        )?;

        Ok(Self {
            hostname,
            username,
            kdf: "scrypt".to_string(),
            n: 2_u32.pow(u32::from(params.log_n())),
            r: params.r(),
            p: params.p(),
            created: with_created.then(Local::now),
            data,
            salt,
        })
    }

    /// Get a [`KeyFile`] from the backend
    fn from_backend<B: ReadBackend>(be: &B, id: &Id) -> RusticResult<Self> {
        let data = be.read_full(FileType::Key, id)?;
        Ok(
            serde_json::from_slice(&data)
                .map_err(KeyFileErrorKind::DeserializingFromSliceFailed)?,
        )
    }
}

fn log_2(x: u32) -> RusticResult<u8> {
    assert!(x > 0);
    Ok(u8::try_from(constants::num_bits::<u32>())
        .map_err(KeyFileErrorKind::ConversionFromU32ToU8Failed)?
        - u8::try_from(x.leading_zeros()).map_err(KeyFileErrorKind::ConversionFromU32ToU8Failed)?
        - 1)
}

#[serde_as]
#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct Mac {
    #[serde_as(as = "Base64")]
    k: Vec<u8>,
    #[serde_as(as = "Base64")]
    r: Vec<u8>,
}

#[serde_as]
#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct MasterKey {
    mac: Mac,
    #[serde_as(as = "Base64")]
    encrypt: Vec<u8>,
}

impl MasterKey {
    fn from_key(key: Key) -> Self {
        let (encrypt, k, r) = key.to_keys();
        Self {
            encrypt,
            mac: Mac { k, r },
        }
    }

    fn key(&self) -> Key {
        Key::from_keys(&self.encrypt, &self.mac.k, &self.mac.r)
    }
}

pub(crate) fn key_from_backend<B: ReadBackend>(
    be: &B,
    id: &Id,
    passwd: &SecretPassword,
) -> RusticResult<Key> {
    KeyFile::from_backend(be, id)?.key_from_password(passwd)
}

/// Find a [`KeyFile`] in the backend that fits to the given password and return the contained key.
/// If a key hint is given, only this key is tested.
/// This is recommended for a large number of keys.
pub(crate) fn find_key_in_backend<B: ReadBackend>(
    be: &B,
    passwd: &SecretPassword,
    hint: Option<&Id>,
) -> RusticResult<Key> {
    if let Some(id) = hint {
        key_from_backend(be, id, passwd)
    } else {
        for id in be.list(FileType::Key)? {
            if let Ok(key) = key_from_backend(be, &id, passwd) {
                return Ok(key);
            }
        }
        Err(KeyFileErrorKind::NoSuitableKeyFound.into())
    }
}
